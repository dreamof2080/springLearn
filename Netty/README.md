# Netty学习

## java的IO模型
IO模型：用什么样的数据流通道进行数据的发送和接收，不同的IO模型决定了程序通信的性能。
目前java支持3种网络编程IO模型：分别是BIO、NIO、AIO

### BIO (同步阻塞)
BIO是JDK1.4版本之前常用的编程方式。
服务实现模式为一个连接创建一个线程，即客户端有连接请求时，服务端就需要启动一个线程进行处理，
如果这个连接不做任何事情就会一直阻塞着，造成不必要的线程开销。
虽然可以用线程池优化技术，但是还是避免不了客户端连接请求创建一个线程资源的局面。

BIO方式适用于连接数量比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用仲，
但程序简单易理解。

### NIO (同步非阻塞)
服务器实现模式为一个线程处理多个请求连接，客户端发送的连接请求都会注册到多路复用器上，
多路复用器轮询到连及恩有I/O请求就进行处理。

NIO方式适用于连接树木多且连接比较短(轻操作)的架构，比如聊天服务器，弹幕系统，服务器间通讯等。
编程比较复杂，JDK1.4开始支持。

### AIO (异步非阻塞)
AIO的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数多且连接时间较长的应用。

当进行读写的时候，只需要直接调用API的read/write方法即可。这两种方法都是异步的。

对于读操作，当有流可读取的时候，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；

对于写操作，当操作系统将write方法传递的流写入完毕时，操作系统会主动通知应用程序。

所以，可以理解为，read/write方法都是异步的，完成后会主动回调函数。

在JDK7中，也被称作NIO2。

AIO方法使用于连接树木多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS(操作系统)参与并发操作，
编程比较复杂，JDK7开始支持。

### 同步/异步，阻塞/非阻塞
阻塞/非阻塞：进程/线程需要操作的数据如果尚未就绪，是否妨碍了当前进程/线程的后续操作。面向的对象是系统
同步/异步：数据如果尚未就绪，是否需要等待数据结果。勉县的对象是应用程序

## NIO详细介绍
### NIO的基本概念
* NIO: java non-blocking IO，是JDK1.4提供的新API，是同步非阻塞的。
* NIO有三个核心部分 Channel(通道)，Buffer(缓冲区)，Selector(选择器)
* NIO是面向缓冲区(Buffer)或者块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，
这就增加了处理过程中灵活性，使它可以提供非阻塞式的高伸缩性网络。也就是说缓冲区实现了NIO的非阻塞模式。
* NIO的非阻塞模式：使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，
如果目前没有数据可用时，就什么都不会获取，而不时保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做
其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。
* NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来，根据实际情况，可以分配50或者100个线程来处理。
不像之前的阻塞IO（如BIO）那样，非得分配10000个线程。

### NIO和BIO的比较
* BIO以流的方式处理数据，而NIO以块（缓冲区）的方式处理数据，块I/O的效率比流I/O高很多。
* BIO是阻塞的，NIO则是非阻塞的。
* BIO基于字节流和字符流进行操作，而NIO基于Channel（通道）和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，
或者从缓冲区写如到通道中。Selector(选择器)用于监听多个通道的事件（比如：连接请求，数据到达等），
因此使用单个线程就可以监听多个客户端通道。

### Selector、Channel、Buffer的关系
* 一个selector对应一个线程，一个selector对应多个channel
* 程序切换到哪个channel是由事件决定的，Event就是一个重要的概念(事件驱动)
* channel是双向的，可以返回底层操作系统的情况，比如Linux，底层的操作系统通道就是双向的。
* 每个channel又都会对应一个Buffer
* Buffer就是一个内存块、缓冲区，底层是由数组是项的
* 数据的read、write是通过Buffer传输的，这个和BIO不同，BIO中要么是输入流(inputStream)，要么是输出流(outputStream)，
不能双向，但是NIO的Buffer是可以读也可以写，需要且只需要调用flip方法切换。

### Buffer
缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象（含数组），该对象提供了一组API，
可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。
而Channel提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer。

#### Buffer类以及子类
* ByteBuffer: 存储字节数到缓冲区
* ShortBuffer: 存储字符串数据到缓冲区
* CharBuffer: 存储字符数据到缓冲区
* IntBuffer: 存储整数数据到缓冲区
* LongBuffer: 存储长整型数据到缓冲区
* DoubleBuffer: 存储小数到缓冲区
* FloatBuffer: 存储小数到缓冲区

#### Buffer缓冲区的4各核心属性

| 属性 | 描述 |
|--- | ---- |
| Capacity | 容量，即可以容纳的最大数据量；在缓冲区创建时被设定并且不能改变 |
| Limit | 表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的|
| Position | 位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变该值，为下次读写做准备|
| Mark | 标记 |

#### ByteBuffer
ByteBuffer支持特定类型的put和get，特定类型的put时，相应的get时必须和put对应起来，否则无法获取正确的值：
```markdown
    // 创建一个Buffer
    ByteBuffer buffer = ByteBuffer.allocate(64);
    // 类型化方式放入数据
    buffer.putInt(88);
    buffer.putLong(6L);
    buffer.putChar('朱');
    buffer.putShort((short) 11);
    // 取出
    buffer.flip();
    System.out.println(buffer.getInt());
    System.out.println(buffer.getLong());
    System.out.println(buffer.getChar());
    System.out.println(buffer.getShort());
```